"use strict";

function timezones_list(){
	var tz = new TimezoneDetector();
	return tz.getList();
}

function timezones_guess(){
	var tz = new TimezoneDetector();
	var opts = {};
	if (arguments.length > 0) opts.default = arguments[0];
	var ret = tz.detect(opts);
	return ret.zoneId;
}

;(function() {

	var root = this;
	var previous_detector = root.TimezoneDetector;

	var tz = function(){

		var self = this;

		self.getList = function(){

			return _list;
		}

		self.detect = function(opts){

			var out = {
				'zoneId' : 'America/Los_Angeles',
				'method' : 'gave_up',
			};

			if (opts && opts.default){
				out.zoneId = opts.default;
				out.method = 'default';
			}


			out.intl = _try_using_api();
			var api_guess = out.intl.zoneId;

			if (api_guess){
				// is this one of our choices?
				for (var i=0; i<_list.length; i++){
					if (_list[i][1] == api_guess){
						out.zoneId = api_guess;
						out.method = 'intlapi_exact';
						return out;
					}
				}
				// does it map to a manual equivalent?
				if (_manual_alts[api_guess]){
					out.zoneId = _manual_alts[api_guess];
					out.method = 'intl_api_manual';
					return out;
				}
				// does it map directly to one of our choices?
				if (_alternatives[api_guess]){
					out.zoneId = _alternatives[api_guess];
					out.method = 'intl_api_equivalent';
					return out;
				}
			}

			// use auto-detection via probe dates
			out.probe = _try_using_probe();

			if (out.probe.zoneId){
				out.zoneId = out.probe.zoneId;
				out.method = 'date_probe';
				return out;
			}

			//console.log('no match for TZ on key '+key);

			return out;
		}

		var _try_using_api = function(){

			var out = {
				'zoneId'	: null,
				'hasIntl'	: false,
				'hasDateTime'	: false,
				'hasOptions'	: false,
			};

			try {
				if (typeof Intl === "undefined") return out;

				out.hasIntl = true;

				if (typeof Intl.DateTimeFormat === "undefined") return out;
				var format = Intl.DateTimeFormat();
				if (typeof format === "undefined") return out;

				out.hasDateTime = true;

				if (typeof format.resolvedOptions === "undefined") return out;

				out.hasOptions = true;
				out.zoneId = format.resolvedOptions().timeZone;

			}catch (e){
				return out;
			}

			return out;
		};

		var _try_using_probe = function(){

			var key_parts = [];
#DATES#

			for (var i=1; i<=key_parts.length; i++){

				var key = key_parts.slice(0,i).join(':');
				if (_map[key]){
					return {
						'zoneId'	: _map[key],
						'probeKey'	: key,
						'fullKey'	: key_parts.join(':')
					};
				}
			}

			return {
				'zoneId'	: null,
				'fullKey'	: key_parts.join(':')
			};
		}


		var _map = #MAP#;

		var _list = #LIST#;

		// mappings of zones that Windows returns, but we don't have in our master list.
		// we explicitly list them here because we can't always do an automated mapping
		// of their equivilence into `_alternatives`.
		var _manual_alts = {
			"America/Guatemala" : "America/Belize",
			"America/Indianapolis" : "America/Indiana/Indianapolis",
			"America/La_Paz" : "America/Manaus",
			"UTC" : "Africa/Monrovia",
			"Atlantic/Reykjavik" : "Africa/Monrovia",
			"Europe/Berlin" : "Europe/Amsterdam",
			"Europe/Budapest" : "Europe/Belgrade",
			"Europe/Paris" : "Europe/Brussels",
			"Africa/Lagos" : "Africa/Algiers",
			"Europe/Bucharest" : "Europe/Athens",
			"Africa/Johannesburg" : "Africa/Harare",
			"Europe/Kiev" : "Europe/Helsinki",
			"Europe/Istanbul" : "Asia/Istanbul",
			"Asia/Riyadh" : "Asia/Kuwait",
			"Asia/Dubai" : "Asia/Muscat",
			"Asia/Calcutta" : "Asia/Kolkata",
			"Asia/Shanghai" : "Asia/Chongqing",
			"Asia/Singapore" : "Asia/Kuala_Lumpur",
			"Australia/Sydney" : "Australia/Canberra",
			"Pacific/Port_Moresby" : "Pacific/Guam",
			"Asia/Kamchatka" : "Asia/Anadyr"
		};

		var _alternatives = #EXACT#;

		#BROKEN#

		return self;
	}

	// export
	if (typeof exports !== 'undefined'){
		if (typeof module !== 'undefined' && module.exports){
			exports = module.exports = tz;
		}
		exports.TimezoneDetector = tz;
	}else if (typeof define === 'function' && define.amd){
		define(function() { return tz; })
	}else{
		root.TimezoneDetector = tz;
	}

}).call(function(){
	return this || (typeof window !== 'undefined' ? window : global);
}());
