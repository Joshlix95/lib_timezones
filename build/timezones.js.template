"use strict";

function timezones_list(){
	var tz = new TimezoneDetector();
	return tz.getList();
}

function timezones_guess(){
	var tz = new TimezoneDetector();
	var opts = {};
	if (arguments.length > 0) opts.default = arguments[0];
	var ret = tz.detect(opts);
	return ret.zoneId;
}

;(function() {

	var root = this;
	var previous_detector = root.TimezoneDetector;

	var tz = function(){

		var self = this;

		self.getList = function(){

			return _list;
		}

		self.detect = function(opts){

			var out = {
				'zoneId' : 'America/Los_Angeles',
				'method' : 'gave_up',
			};

			if (opts && opts.default){
				out.zoneId = opts.default;
				out.method = 'default';
			}


			out.intl = _try_using_api();
			var api_guess = out.intl.zoneId;

			if (api_guess){
				// is this one of our choices?
				for (var i in _map){
					if (_map[i] == api_guess){
						out.zoneId = api_guess;
						out.method = 'intlapi_exact';
						return out;
					}
				}
				// does it map directly to one of our choices?
				if (_alternatives[api_guess]){
					out.zoneId = _alternatives[api_guess];
					out.method = 'intl_api_equivalent';
					return out;
				}
			}

			// use auto-detection via probe dates
			var key = _build_probe_key();
			if (_map[key]){
				out.zoneId = _map[key];
				out.method = 'date_probe';
				out.probeKey = key;
				return out;
			}

			//console.log('no match for TZ on key '+key);

			return out;
		}

		var _try_using_api = function(){

			var out = {
				'zoneId'	: null,
				'hasIntl'	: false,
				'hasDateTime'	: false,
				'hasOptions'	: false,
			};

			try {
				if (typeof Intl === "undefined") return out;

				out.hasIntl = true;

				if (typeof Intl.DateTimeFormat === "undefined") return out;
				var format = Intl.DateTimeFormat();
				if (typeof format === "undefined") return out;

				out.hasDateTime = true;

				if (typeof format.resolvedOptions === "undefined") return out;

				out.hasOptions = true;
				out.zoneId = format.resolvedOptions().timeZone;

			}catch (e){
				return out;
			}

			return out;
		};

		var _build_probe_key = function(){

			var key_parts = [];
#DATES#
			var key = key_parts.join(':');

			return key;
		}


		var _map = #MAP#;

		var _list = #LIST#;

		var _alternatives = #EXACT#;

		#BROKEN#

		return self;
	}

	// export
	if (typeof exports !== 'undefined'){
		if (typeof module !== 'undefined' && module.exports){
			exports = module.exports = tz;
		}
		exports.TimezoneDetector = tz;
	}else if (typeof define === 'function' && define.amd){
		define(function() { return tz; })
	}else{
		root.TimezoneDetector = tz;
	}

}).call(function(){
	return this || (typeof window !== 'undefined' ? window : global);
}());
